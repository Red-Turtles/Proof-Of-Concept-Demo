<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CAPTCHA Tutorial (Single-file)</title>
  <style>
    /* Inlined from styles.css */
    :root {
      --bg: #0b0f14;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #60a5fa;
      --code-bg: #0f172a;
      --code-border: #1f2937;
    }

    html { font-size: 16px; }
    body {
      margin: 0;
      padding: 2rem;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      line-height: 1.65;
    }
    main, article {
      max-width: 900px;
      margin: 0 auto;
      background: var(--panel);
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      padding: 2rem 2.25rem;
    }

    h1, h2, h3, h4 { line-height: 1.25; }
    h1 { font-size: 2rem; margin-top: 0; }
    h2 { font-size: 1.5rem; margin-top: 2rem; }
    h3 { font-size: 1.25rem; margin-top: 1.5rem; }
    h4 { font-size: 1.1rem; margin-top: 1.25rem; color: var(--muted); }

    hr { border: 0; height: 1px; background: #1f2937; margin: 2rem 0; }

    code, pre, kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    pre {
      background: var(--code-bg);
      border: 1px solid var(--code-border);
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
    }
    code { color: #f8fafc; }

    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    ul { padding-left: 1.25rem; }
    li { margin: .25rem 0; }

    blockquote {
      margin: 1rem 0;
      padding: .75rem 1rem;
      background: #0d1320;
      border-left: 4px solid var(--accent);
    }

    .table-like { display: grid; grid-template-columns: 1fr 3fr; gap: .5rem 1rem; }
    .table-like > div { padding: .25rem 0; }
  </style>
</head>
<body>
  <main>
    <article>
      <h1>Cursor AI Tutorial: Implementing CAPTCHA Protection in Your Web App</h1>

      <h4>Overview</h4>
      <p>This case study-style tutorial walks through planning, integrating, and hardening CAPTCHA in a modern web application. It covers selecting a provider, implementing both frontend and backend verification, accessibility/UX considerations, common pitfalls, and production-readiness guidance. Examples include Google reCAPTCHA, hCaptcha, Cloudflare Turnstile, and a simple self-hosted fallback.</p>

      <h4>The Task</h4>
      <ul>
        <li><strong>User Request</strong>: “Add a CAPTCHA to my contact, signup, and login forms with minimal friction.”</li>
        <li><strong>Follow-up</strong>: “How do I verify it on the server?”</li>
        <li><strong>Final Request</strong>: “Can I avoid Google and keep it privacy-friendly? Also provide a fallback.”</li>
      </ul>

      <hr />

      <h2>Step-by-Step Process</h2>

      <h3>1) Initial Planning and Threat Model</h3>
      <ul>
        <li><strong>Identify abuse vectors</strong>: credential stuffing, signup spam, contact form abuse, scraping, brute-force attempts.</li>
        <li><strong>Define constraints</strong>:
          <ul>
            <li>Privacy and compliance needs (GDPR/CCPA).</li>
            <li>Accessibility requirements (keyboard-only, screen readers).</li>
            <li>Regions and blocklists (China, Iran restrictions).</li>
            <li>UX tolerance (checkbox vs. invisible vs. passive score).</li>
          </ul>
        </li>
        <li><strong>Choose a strategy</strong>:
          <ul>
            <li>Low friction: Cloudflare Turnstile.</li>
            <li>Balanced: reCAPTCHA v2 Invisible or hCaptcha checkbox.</li>
            <li>No third-party: lightweight self-hosted math/text fallback (paired with rate limiting).</li>
          </ul>
        </li>
      </ul>

      <h3>2) Provider Selection (quick comparison)</h3>
      <ul>
        <li><strong>reCAPTCHA</strong>: ubiquitous, robust, Google dependency, privacy concerns in some orgs.</li>
        <li><strong>hCaptcha</strong>: privacy-focused, free tier, robust, similar integration to reCAPTCHA.</li>
        <li><strong>Cloudflare Turnstile</strong>: privacy-first, very low friction, easy integration, generous free tier.</li>
        <li><strong>Self-hosted fallback</strong>: full control, lowest friction possible, less bot-resilient alone—pair with rate limiting and heuristics.</li>
      </ul>

      <h3>3) Frontend Integration</h3>

      <p><strong>Google reCAPTCHA v2 (checkbox)</strong>:</p>
      <pre><code class="language-html">&lt;script src="https://www.google.com/recaptcha/api.js" async defer&gt;&lt;/script&gt;
&lt;form action="/contact" method="POST"&gt;
  &lt;!-- your form fields --&gt;
  &lt;div class="g-recaptcha" data-sitekey="YOUR_SITE_KEY"&gt;&lt;/div&gt;
  &lt;button type="submit"&gt;Send&lt;/button&gt;
&lt;/form&gt;
</code></pre>
      <p>Token field name: <code>g-recaptcha-response</code></p>

      <p><strong>hCaptcha (checkbox)</strong>:</p>
      <pre><code class="language-html">&lt;script src="https://js.hcaptcha.com/1/api.js" async defer&gt;&lt;/script&gt;
&lt;form action="/contact" method="POST"&gt;
  &lt;!-- your form fields --&gt;
  &lt;div class="h-captcha" data-sitekey="YOUR_SITE_KEY"&gt;&lt;/div&gt;
  &lt;button type="submit"&gt;Send&lt;/button&gt;
&lt;/form&gt;
</code></pre>
      <p>Token field name: <code>h-captcha-response</code></p>

      <p><strong>Cloudflare Turnstile</strong>:</p>
      <pre><code class="language-html">&lt;script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer&gt;&lt;/script&gt;
&lt;form action="/contact" method="POST"&gt;
  &lt;!-- your form fields --&gt;
  &lt;div class="cf-challenge" data-sitekey="YOUR_SITE_KEY"&gt;&lt;/div&gt;
  &lt;button type="submit"&gt;Send&lt;/button&gt;
&lt;/form&gt;
</code></pre>
      <p>Token field name: <code>cf-turnstile-response</code></p>

      <p><strong>Tips</strong>:</p>
      <ul>
        <li>Place widgets near the submit button.</li>
        <li>Use one widget per form submission (refresh/reset on errors).</li>
        <li>Localize with provider attributes where available.</li>
      </ul>

      <h3>4) Backend Verification</h3>

      <p><strong>Flask (Python) – reCAPTCHA example</strong>:</p>
      <pre><code class="language-python">import os
import requests
from flask import Flask, request, abort

app = Flask(__name__)
RECAPTCHA_SECRET = os.environ["RECAPTCHA_SECRET"]

def verify_recaptcha(token: str, remote_ip: str | None = None) -&gt; bool:
    payload = {"secret": RECAPTCHA_SECRET, "response": token}
    if remote_ip:
        payload["remoteip"] = remote_ip
    resp = requests.post("https://www.google.com/recaptcha/api/siteverify", data=payload, timeout=5)
    data = resp.json()
    return bool(data.get("success"))

@app.post("/contact")
def contact():
    token = request.form.get("g-recaptcha-response")
    if not token or not verify_recaptcha(token, request.remote_addr):
        abort(400, "Captcha validation failed")
    # proceed with processing
    return "OK"
</code></pre>

      <p><strong>Express (Node) – reCAPTCHA example</strong>:</p>
      <pre><code class="language-javascript">import express from 'express';
import fetch from 'node-fetch';

const app = express();
app.use(express.urlencoded({ extended: true }));
const SECRET = process.env.RECAPTCHA_SECRET;

app.post('/contact', async (req, res) =&gt; {
  const token = req.body['g-recaptcha-response'];
  if (!token) return res.status(400).send('Captcha missing');

  const response = await fetch('https://www.google.com/recaptcha/api/siteverify', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({ secret: SECRET, response: token })
  });
  const data = await response.json();
  if (!data.success) return res.status(400).send('Captcha failed');

  // proceed with processing
  res.send('OK');
});
</code></pre>

      <p><strong>Adjust endpoints for other providers</strong>:</p>
      <ul>
        <li>hCaptcha verify: <code>https://hcaptcha.com/siteverify</code></li>
        <li>Turnstile verify: <code>https://challenges.cloudflare.com/turnstile/v0/siteverify</code></li>
      </ul>
      <p>Always send the server-side secret; never expose it on the client.</p>

      <h3>5) Self-Hosted Fallback (simple, lightweight)</h3>
      <p><strong>HTML</strong>:</p>
      <pre><code class="language-html">&lt;form action="/contact" method="POST"&gt;
  &lt;!-- your fields --&gt;
  &lt;label for="captcha"&gt;What is 7 + 5?&lt;/label&gt;
  &lt;input id="captcha" name="captcha_answer" required&gt;
  &lt;input type="hidden" name="captcha_expected" value="12"&gt;
  &lt;button type="submit"&gt;Send&lt;/button&gt;
&lt;/form&gt;
</code></pre>

      <p><strong>Flask example (session-backed is better than hidden fields)</strong>:</p>
      <pre><code class="language-python">import os, secrets
from flask import Flask, session, request, abort

app = Flask(__name__)
app.secret_key = os.environ["APP_SECRET_KEY"]

@app.get("/contact")
def contact_form():
    # generate and store expected answer in session
    a, b = 7, 5  # replace with random
    session["captcha_expected"] = str(a + b)
    # render template showing the question
    return f"""
      &lt;form method="POST"&gt;
        &lt;label&gt;What is {a} + {b}?&lt;/label&gt;
        &lt;input name="captcha_answer" required&gt;
        &lt;button type="submit"&gt;Send&lt;/button&gt;
      &lt;/form&gt;
    """

@app.post("/contact")
def contact_submit():
    expected = session.pop("captcha_expected", None)
    if not expected or request.form.get("captcha_answer") != expected:
        abort(400, "Captcha incorrect")
    return "OK"
</code></pre>
      <p>Pair with rate limiting, IP heuristics, and honeypots for meaningful protection.</p>

      <h3>6) UX, Accessibility, and Localization</h3>
      <ul>
        <li>Ensure keyboard navigability and proper focus states.</li>
        <li>Provide ARIA labels and descriptive instructions.</li>
        <li>Offer audio challenge or alternative where supported.</li>
        <li>Localize widget text using provider attributes.</li>
        <li>Avoid blocking when provider scripts fail—graceful fallbacks.</li>
      </ul>

      <h3>7) Security Hardening</h3>
      <ul>
        <li>Verify on the server only; never trust client claims.</li>
        <li>Rate limit endpoints (e.g., IP + account + user-agent tuples).</li>
        <li>Bind CAPTCHA to a session or nonce; reject replayed tokens.</li>
        <li>Enforce token freshness and one-time-use semantics.</li>
        <li>Add honeypot fields and submission time checks (too-fast submissions).</li>
        <li>Protect with CSRF tokens; deny on mismatch.</li>
        <li>Log failures with context (no secrets), alert on spikes.</li>
        <li>Rotate secrets regularly; store in a vault or env vars.</li>
      </ul>

      <h3>8) Testing and Monitoring</h3>
      <ul>
        <li>Unit test: valid token, missing token, invalid token, replay attempts.</li>
        <li>Integration test: full form flow including error rendering and retry.</li>
        <li>Manual test with script failures, ad blockers, slow networks.</li>
        <li>Observability: track pass/fail rates, latency to verification endpoints, and CAPTCHAs per endpoint.</li>
      </ul>

      <hr />

      <h2>Pros of Using Cursor AI for This Task</h2>
      <ul>
        <li><strong>Structured Execution</strong>: Broke down selection, integration, and hardening into clear steps.</li>
        <li><strong>Provider-Agnostic Guidance</strong>: Reusable patterns for reCAPTCHA, hCaptcha, and Turnstile.</li>
        <li><strong>Production Focus</strong>: Emphasis on server-side verification, rate limiting, and monitoring.</li>
        <li><strong>Developer Experience</strong>: Copy-paste examples for Flask and Express.</li>
      </ul>

      <h2>Cons and Limitations</h2>
      <ul>
        <li><strong>Third-Party Dependence</strong>: External verification endpoints can fail or be blocked.</li>
        <li><strong>Accessibility Trade-offs</strong>: Some challenges remain difficult for assistive tech.</li>
        <li><strong>Regional Constraints</strong>: Certain providers may not work in all regions.</li>
        <li><strong>Self-Hosted Weakness</strong>: Simple captchas alone are easier to bypass—must be layered.</li>
      </ul>

      <h2>Key Learnings for Cursor AI Users</h2>
      <ul>
        <li><strong>Start with Requirements</strong>: Privacy, region, accessibility, friction.</li>
        <li><strong>Always Verify Server-Side</strong>: Client-side checks are insufficient.</li>
        <li><strong>Layer Defenses</strong>: CAPTCHA + rate limiting + CSRF + heuristics.</li>
        <li><strong>Design for Failure</strong>: Graceful degradation and clear user errors.</li>
        <li><strong>Monitor in Production</strong>: Alert on anomaly spikes and token errors.</li>
      </ul>

      <h2>Technical Recommendations</h2>
      <ul>
        <li><strong>Providers</strong>: Prefer Turnstile for privacy/UX, hCaptcha for privacy balance, reCAPTCHA for ubiquity.</li>
        <li><strong>Secrets</strong>: Keep in env vars; rotate periodically.</li>
        <li><strong>Networking</strong>: Add timeouts and retries to verification calls; cache short-lived provider public keys if needed.</li>
        <li><strong>Framework Add-ons</strong>:
          <ul>
            <li>Flask: <code>Flask-Limiter</code> for rate limiting, CSRF via <code>flask-wtf</code> or <code>itsdangerous</code>.</li>
            <li>Express: <code>express-rate-limit</code>, <code>helmet</code>, CSRF via <code>csurf</code>.</li>
          </ul>
        </li>
        <li><strong>Fallback</strong>: Implement a self-hosted math challenge for script-blocked environments, but keep it behind rate limiting.</li>
      </ul>

      <h2>Overall Assessment</h2>
      <ul>
        <li><strong>Success Rate</strong>: 90%</li>
        <li><strong>What Worked Well</strong>: Clear provider-agnostic flow, concise integration snippets, strong hardening guidance.</li>
        <li><strong>What Could Improve</strong>: Region-specific caveats, richer a11y patterns, more SPA examples.</li>
      </ul>

      <h2>Conclusion</h2>
      <p>Implementing CAPTCHA effectively is about thoughtful provider choice, strict server-side verification, layered defenses, and good UX. Use the snippets above to integrate your chosen provider, add a self-hosted fallback for resiliency, and harden with rate limiting and CSRF. With monitoring in place, you’ll significantly reduce automated abuse without burdening legitimate users.</p>
    </article>
  </main>
</body>
</html>