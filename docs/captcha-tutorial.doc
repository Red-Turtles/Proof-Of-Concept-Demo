<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>CAPTCHA Tutorial (Word-compatible)</title>
  <style>
    body { font-family: Calibri, Arial, sans-serif; color: #111; line-height: 1.5; }
    h1 { font-size: 22pt; }
    h2 { font-size: 18pt; margin-top: 18pt; }
    h3 { font-size: 15pt; margin-top: 14pt; }
    h4 { font-size: 13pt; color: #333; }
    pre { background: #f6f8fa; border: 1px solid #e2e8f0; padding: 10px; white-space: pre-wrap; }
    code { font-family: Consolas, 'Courier New', monospace; }
    ul { margin: 0; padding-left: 20px; }
    hr { border: 0; border-top: 1px solid #e2e8f0; margin: 16px 0; }
    .muted { color: #555; }
  </style>
</head>
<body>
  <h1>Cursor AI Tutorial: Implementing CAPTCHA Protection in Your Web App</h1>
  <h4 class="muted">Overview</h4>
  <p>This case study-style tutorial walks through planning, integrating, and hardening CAPTCHA in a modern web application. It covers selecting a provider, implementing both frontend and backend verification, accessibility/UX considerations, common pitfalls, and production-readiness guidance. Examples include Google reCAPTCHA, hCaptcha, Cloudflare Turnstile, and a simple self-hosted fallback.</p>

  <h4 class="muted">The Task</h4>
  <ul>
    <li><strong>User Request</strong>: “Add a CAPTCHA to my contact, signup, and login forms with minimal friction.”</li>
    <li><strong>Follow-up</strong>: “How do I verify it on the server?”</li>
    <li><strong>Final Request</strong>: “Can I avoid Google and keep it privacy-friendly? Also provide a fallback.”</li>
  </ul>

  <hr>

  <h2>Step-by-Step Process</h2>

  <h3>1) Initial Planning and Threat Model</h3>
  <ul>
    <li><strong>Identify abuse vectors</strong>: credential stuffing, signup spam, contact form abuse, scraping, brute-force attempts.</li>
    <li><strong>Define constraints</strong>:
      <ul>
        <li>Privacy and compliance needs (GDPR/CCPA).</li>
        <li>Accessibility requirements (keyboard-only, screen readers).</li>
        <li>Regions and blocklists (China, Iran restrictions).</li>
        <li>UX tolerance (checkbox vs. invisible vs. passive score).</li>
      </ul>
    </li>
    <li><strong>Choose a strategy</strong>:
      <ul>
        <li>Low friction: Cloudflare Turnstile.</li>
        <li>Balanced: reCAPTCHA v2 Invisible or hCaptcha checkbox.</li>
        <li>No third-party: lightweight self-hosted math/text fallback (paired with rate limiting).</li>
      </ul>
    </li>
  </ul>

  <h3>2) Provider Selection (quick comparison)</h3>
  <ul>
    <li><strong>reCAPTCHA</strong>: ubiquitous, robust, Google dependency, privacy concerns in some orgs.</li>
    <li><strong>hCaptcha</strong>: privacy-focused, free tier, robust, similar integration to reCAPTCHA.</li>
    <li><strong>Cloudflare Turnstile</strong>: privacy-first, very low friction, easy integration, generous free tier.</li>
    <li><strong>Self-hosted fallback</strong>: full control, lowest friction possible, less bot-resilient alone—pair with rate limiting and heuristics.</li>
  </ul>

  <h3>3) Frontend Integration</h3>

  <p><strong>Google reCAPTCHA v2 (checkbox)</strong>:</p>
  <pre><code>&lt;script src="https://www.google.com/recaptcha/api.js" async defer&gt;&lt;/script&gt;
&lt;form action="/contact" method="POST"&gt;
  &lt;!-- your form fields --&gt;
  &lt;div class="g-recaptcha" data-sitekey="YOUR_SITE_KEY"&gt;&lt;/div&gt;
  &lt;button type="submit"&gt;Send&lt;/button&gt;
&lt;/form&gt;</code></pre>
  <p>Token field name: <code>g-recaptcha-response</code></p>

  <p><strong>hCaptcha (checkbox)</strong>:</p>
  <pre><code>&lt;script src="https://js.hcaptcha.com/1/api.js" async defer&gt;&lt;/script&gt;
&lt;form action="/contact" method="POST"&gt;
  &lt;!-- your form fields --&gt;
  &lt;div class="h-captcha" data-sitekey="YOUR_SITE_KEY"&gt;&lt;/div&gt;
  &lt;button type="submit"&gt;Send&lt;/button&gt;
&lt;/form&gt;</code></pre>
  <p>Token field name: <code>h-captcha-response</code></p>

  <p><strong>Cloudflare Turnstile</strong>:</p>
  <pre><code>&lt;script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer&gt;&lt;/script&gt;
&lt;form action="/contact" method="POST"&gt;
  &lt;!-- your form fields --&gt;
  &lt;div class="cf-challenge" data-sitekey="YOUR_SITE_KEY"&gt;&lt;/div&gt;
  &lt;button type="submit"&gt;Send&lt;/button&gt;
&lt;/form&gt;</code></pre>
  <p>Token field name: <code>cf-turnstile-response</code></p>

  <p><strong>Tips</strong>:</p>
  <ul>
    <li>Place widgets near the submit button.</li>
    <li>Use one widget per form submission (refresh/reset on errors).</li>
    <li>Localize with provider attributes where available.</li>
  </ul>

  <h3>4) Backend Verification</h3>

  <p><strong>Flask (Python) – reCAPTCHA example</strong>:</p>
  <pre><code>import os
import requests
from flask import Flask, request, abort

app = Flask(__name__)
RECAPTCHA_SECRET = os.environ["RECAPTCHA_SECRET"]

def verify_recaptcha(token: str, remote_ip: str | None = None) -&gt; bool:
    payload = {"secret": RECAPTCHA_SECRET, "response": token}
    if remote_ip:
        payload["remoteip"] = remote_ip
    resp = requests.post("https://www.google.com/recaptcha/api/siteverify", data=payload, timeout=5)
    data = resp.json()
    return bool(data.get("success"))

@app.post("/contact")
def contact():
    token = request.form.get("g-recaptcha-response")
    if not token or not verify_recaptcha(token, request.remote_addr):
        abort(400, "Captcha validation failed")
    # proceed with processing
    return "OK"</code></pre>

  <p><strong>Express (Node) – reCAPTCHA example</strong>:</p>
  <pre><code>import express from 'express';
import fetch from 'node-fetch';

const app = express();
app.use(express.urlencoded({ extended: true }));
const SECRET = process.env.RECAPTCHA_SECRET;

app.post('/contact', async (req, res) =&gt; {
  const token = req.body['g-recaptcha-response'];
  if (!token) return res.status(400).send('Captcha missing');

  const response = await fetch('https://www.google.com/recaptcha/api/siteverify', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({ secret: SECRET, response: token })
  });
  const data = await response.json();
  if (!data.success) return res.status(400).send('Captcha failed');

  // proceed with processing
  res.send('OK');
});</code></pre>

  <p><strong>Adjust endpoints for other providers</strong>:</p>
  <ul>
    <li>hCaptcha verify: <code>https://hcaptcha.com/siteverify</code></li>
    <li>Turnstile verify: <code>https://challenges.cloudflare.com/turnstile/v0/siteverify</code></li>
  </ul>
  <p>Always send the server-side secret; never expose it on the client.</p>

  <h3>5) Self-Hosted Fallback (simple, lightweight)</h3>
  <p><strong>HTML</strong>:</p>
  <pre><code>&lt;form action="/contact" method="POST"&gt;
  &lt;!-- your fields --&gt;
  &lt;label for="captcha"&gt;What is 7 + 5?&lt;/label&gt;
  &lt;input id="captcha" name="captcha_answer" required&gt;
  &lt;input type="hidden" name="captcha_expected" value="12"&gt;
  &lt;button type="submit"&gt;Send&lt;/button&gt;
&lt;/form&gt;</code></pre>

  <p><strong>Flask example (session-backed is better than hidden fields)</strong>:</p>
  <pre><code>import os, secrets
from flask import Flask, session, request, abort

app = Flask(__name__)
app.secret_key = os.environ["APP_SECRET_KEY"]

@app.get("/contact")
def contact_form():
    # generate and store expected answer in session
    a, b = 7, 5  # replace with random
    session["captcha_expected"] = str(a + b)
    # render template showing the question
    return f"""
      &lt;form method="POST"&gt;
        &lt;label&gt;What is {a} + {b}?&lt;/label&gt;
        &lt;input name="captcha_answer" required&gt;
        &lt;button type="submit"&gt;Send&lt;/button&gt;
      &lt;/form&gt;
    """

@app.post("/contact")
def contact_submit():
    expected = session.pop("captcha_expected", None)
    if not expected or request.form.get("captcha_answer") != expected:
        abort(400, "Captcha incorrect")
    return "OK"</code></pre>
  <p>Pair with rate limiting, IP heuristics, and honeypots for meaningful protection.</p>

  <h3>6) UX, Accessibility, and Localization</h3>
  <ul>
    <li>Ensure keyboard navigability and proper focus states.</li>
    <li>Provide ARIA labels and descriptive instructions.</li>
    <li>Offer audio challenge or alternative where supported.</li>
    <li>Localize widget text using provider attributes.</li>
    <li>Avoid blocking when provider scripts fail—graceful fallbacks.</li>
  </ul>

  <h3>7) Security Hardening</h3>
  <ul>
    <li>Verify on the server only; never trust client claims.</li>
    <li>Rate limit endpoints (e.g., IP + account + user-agent tuples).</li>
    <li>Bind CAPTCHA to a session or nonce; reject replayed tokens.</li>
    <li>Enforce token freshness and one-time-use semantics.</li>
    <li>Add honeypot fields and submission time checks (too-fast submissions).</li>
    <li>Protect with CSRF tokens; deny on mismatch.</li>
    <li>Log failures with context (no secrets), alert on spikes.</li>
    <li>Rotate secrets regularly; store in a vault or env vars.</li>
  </ul>

  <h3>8) Testing and Monitoring</h3>
  <ul>
    <li>Unit test: valid token, missing token, invalid token, replay attempts.</li>
    <li>Integration test: full form flow including error rendering and retry.</li>
    <li>Manual test with script failures, ad blockers, slow networks.</li>
    <li>Observability: track pass/fail rates, latency to verification endpoints, and CAPTCHAs per endpoint.</li>
  </ul>

  <hr>

  <h2>Pros of Using Cursor AI for This Task</h2>
  <ul>
    <li><strong>Structured Execution</strong>: Broke down selection, integration, and hardening into clear steps.</li>
    <li><strong>Provider-Agnostic Guidance</strong>: Reusable patterns for reCAPTCHA, hCaptcha, and Turnstile.</li>
    <li><strong>Production Focus</strong>: Emphasis on server-side verification, rate limiting, and monitoring.</li>
    <li><strong>Developer Experience</strong>: Copy-paste examples for Flask and Express.</li>
  </ul>

  <h2>Cons and Limitations</h2>
  <ul>
    <li><strong>Third-Party Dependence</strong>: External verification endpoints can fail or be blocked.</li>
    <li><strong>Accessibility Trade-offs</strong>: Some challenges remain difficult for assistive tech.</li>
    <li><strong>Regional Constraints</strong>: Certain providers may not work in all regions.</li>
    <li><strong>Self-Hosted Weakness</strong>: Simple captchas alone are easier to bypass—must be layered.</li>
  </ul>

  <h2>Key Learnings for Cursor AI Users</h2>
  <ul>
    <li><strong>Start with Requirements</strong>: Privacy, region, accessibility, friction.</li>
    <li><strong>Always Verify Server-Side</strong>: Client-side checks are insufficient.</li>
    <li><strong>Layer Defenses</strong>: CAPTCHA + rate limiting + CSRF + heuristics.</li>
    <li><strong>Design for Failure</strong>: Graceful degradation and clear user errors.</li>
    <li><strong>Monitor in Production</strong>: Alert on anomaly spikes and token errors.</li>
  </ul>

  <h2>Technical Recommendations</h2>
  <ul>
    <li><strong>Providers</strong>: Prefer Turnstile for privacy/UX, hCaptcha for privacy balance, reCAPTCHA for ubiquity.</li>
    <li><strong>Secrets</strong>: Keep in env vars; rotate periodically.</li>
    <li><strong>Networking</strong>: Add timeouts and retries to verification calls; cache short-lived provider public keys if needed.</li>
    <li><strong>Framework Add-ons</strong>:
      <ul>
        <li>Flask: <code>Flask-Limiter</code> for rate limiting, CSRF via <code>flask-wtf</code> or <code>itsdangerous</code>.</li>
        <li>Express: <code>express-rate-limit</code>, <code>helmet</code>, CSRF via <code>csurf</code>.</li>
      </ul>
    </li>
    <li><strong>Fallback</strong>: Implement a self-hosted math challenge for script-blocked environments, but keep it behind rate limiting.</li>
  </ul>

  <h2>Overall Assessment</h2>
  <ul>
    <li><strong>Success Rate</strong>: 90%</li>
    <li><strong>What Worked Well</strong>: Clear provider-agnostic flow, concise integration snippets, strong hardening guidance.</li>
    <li><strong>What Could Improve</strong>: Region-specific caveats, richer a11y patterns, more SPA examples.</li>
  </ul>

  <h2>Conclusion</h2>
  <p>Implementing CAPTCHA effectively is about thoughtful provider choice, strict server-side verification, layered defenses, and good UX. Use the snippets above to integrate your chosen provider, add a self-hosted fallback for resiliency, and harden with rate limiting and CSRF. With monitoring in place, you’ll significantly reduce automated abuse without burdening legitimate users.</p>
</body>
</html>